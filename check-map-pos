#!/usr/bin/env python3

import argparse
import logging
import os
import sys
import numpy as np
from collections import Counter

def load_data(in_f):
    _d = np.genfromtxt(in_f.buffer, names=True, dtype=None)
    res = dict()
    for i in range(len(_d)):
        read_name = _d[i]['read_name'].decode()
        read_type = _d[i]['read_type'].decode()
        if read_name not in res:
            res[read_name] = dict()
        res[read_name][read_type] = [
            # ref_start
            _d[i]['align_pos'],
            # ref_end
            _d[i]['align_pos'] + _d[i]['align_len'],
            # read length
            _d[i]['read_len'] + _d[i]['unalign_len'],
            # fraction aligned
            _d[i]['read_len'] / (_d[i]['read_len'] + _d[i]['unalign_len']),
            # fraction identity
            _d[i]['matches'] / (_d[i]['matches'] + _d[i]['tot_errors'])]
    return res

def process_data(data, ref_rt):
    # determine read types
    rt_d = dict()
    for rn in data.keys():
        for rt in data[rn].keys():
            rt_d[rt] = True
    if ref_rt in rt_d:
        del rt_d[ref_rt]
    rt_l = sorted(rt_d.keys())
    logger.debug('read_type_list: ' + str(rt_l))
    # now check mapping correctness for each read
    print('read_name\t' + ref_rt + '\t' + '\t'.join(rt_l))
    for rn in data.keys():
        if ref_rt not in data[rn]:
            print(rn + '\t1\t' + '\t'.join(['0'] * len(rt_l)))
            continue
        l = list()
        for rt in rt_l:
            if rt not in data[rn]:
                # missing
                l.append('2')
            elif (min(data[rn][rt][1], data[rn][ref_rt][1])
                - max(data[rn][rt][0], data[rn][ref_rt][0]) <= 0):
                # incorrect
                l.append('1')
            else:
                l.append('0')
        print(rn + '\t0\t' + '\t'.join(l))


if __name__ == "__main__":
    description = """
Check if alignment positions of various read types match the alignment of the reference read type.
    """
    parser = argparse.ArgumentParser(description=description, epilog='')
    parser.add_argument('--log-level', help='log level', action='store', default='info')
    parser.add_argument('-o', '--output', default='-', help='Output summary file.')
    parser.add_argument('-r', '--ref-type', default='metrichor:2', help='Reference alignment type.')
    parser.add_argument('input', nargs='?', default='-', help='Input SAM/BAM summary file.')
    args = parser.parse_args()

    numeric_log_level = getattr(logging, args.log_level.upper(), None)
    if not isinstance(numeric_log_level, int):
        raise ValueError('Invalid log level: "%s"' % args.log_level)
    logging.basicConfig(level=numeric_log_level,
                        format='%(asctime)s %(name)s.%(levelname)s %(message)s',
                        datefmt='%Y/%m/%d %H:%M:%S')
    logger = logging.getLogger(os.path.basename(__file__))
    logger.info('args=' + str(args))

    d = load_data(open(args.input) if args.input != '-' else sys.stdin)
    process_data(d, args.ref_type)
